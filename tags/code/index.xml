<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code on Jamie J Quinn</title><link>https://jamiejquinn.com/tags/code/</link><description>Recent content in Code on Jamie J Quinn</description><generator>Hugo</generator><language>en-GB</language><copyright>Copyright Â© 2024, Jamie J Quinn.</copyright><lastBuildDate>Wed, 20 Jan 2021 18:42:42 +0000</lastBuildDate><atom:link href="https://jamiejquinn.com/tags/code/index.xml" rel="self" type="application/rss+xml"/><item><title>Analysing the prevalence of continuous integration in JOSS</title><link>https://jamiejquinn.com/analysing-the-prevalence-of-continuous-integration-in-joss/</link><pubDate>Wed, 20 Jan 2021 18:42:42 +0000</pubDate><guid>https://jamiejquinn.com/analysing-the-prevalence-of-continuous-integration-in-joss/</guid><description>JOSS is the Journal of Open Source Software and can be considered a collection of some excellent scientific codebases. Whether they&amp;rsquo;re exemplars of good coding practices is up for debate but I wanted to know roughly how many published papers (and associated codebases) were using specifically continuous integration of some form. Luckily I have some experience scraping web pages with python and the excellent webscraping package BeautifulSoup, so I cracked out the old tutorials and set to work.</description></item><item><title>Running Fluid Simulations in WebGL I - Simple Convection</title><link>https://jamiejquinn.com/running-fluid-simulations-in-webgl-i-simple-convection/</link><pubDate>Sun, 29 Jul 2018 00:00:00 +0000</pubDate><guid>https://jamiejquinn.com/running-fluid-simulations-in-webgl-i-simple-convection/</guid><description>Years ago I worked my way through Lorena Barba&amp;rsquo;s 12 steps to Navier-Stokes in Python, but recently I&amp;rsquo;ve been getting more and more into GPU programming and figured that it would be an interesting exercise to redo the steps in WebGL. Really when I say GPU programming I mean using general purpose tech like CUDA, but CUDA and WebGL are similar enough (the boilerplate is of course totally different but the idea of writing a kernel to act on many pixels/fluid cells is the same).</description></item><item><title>Mr. Julia</title><link>https://jamiejquinn.com/mr.-julia/</link><pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate><guid>https://jamiejquinn.com/mr.-julia/</guid><description>Going on my theme of wonderfully fractal images, I wrote a little simulation to introduce myself to webGL. Go have a wee play about with it here.
The Maths You can find lots of information about Julia fractals all around the web so I won&amp;rsquo;t go into much detail at all here. All I&amp;rsquo;ll say is that the fractals, named for Gaston Julia, come about by iterating a complex number through the formula $$z_{n+1} = z_n^2 + c,$$ where \(c\) is some complex number.</description></item><item><title>How I lost a Day to OpenMPI Being Mental</title><link>https://jamiejquinn.com/how-i-lost-a-day-to-openmpi-being-mental/</link><pubDate>Fri, 19 May 2017 13:28:58 +0100</pubDate><guid>https://jamiejquinn.com/how-i-lost-a-day-to-openmpi-being-mental/</guid><description>So at Glasgow Uni we have this little cluster for the maths department which happens to including about ten machines set up to work with torque (a job scheduling system). I discovered that these machines hadn&amp;rsquo;t had anything run on them for literally months, what a waste of resources! To rectify this atrocity I decided to try and run my MPI enabled code on all ten machines.
Problem One Turns out two of the machines have eight cores and the other eight have twelve cores.</description></item><item><title>4 Tips on Making Simulations Bug Resistant</title><link>https://jamiejquinn.com/4-tips-on-making-simulations-bug-resistant/</link><pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate><guid>https://jamiejquinn.com/4-tips-on-making-simulations-bug-resistant/</guid><description>Having written and used a decent number of simulations over the past few years I&amp;rsquo;ve come to understand that preventing bugs in scientific software is just a wee bit different from how it&amp;rsquo;s usually done in more standard software development.
For one thing, many of the simulations come under the category of high performance computing (HPC) simulations, so it can take a long time to build and run a test case, leading to iteration speeds that are painfully slow.</description></item><item><title>Parallelising Wondrous Numbers in C++</title><link>https://jamiejquinn.com/parallelising-wondrous-numbers-in-c-/</link><pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate><guid>https://jamiejquinn.com/parallelising-wondrous-numbers-in-c-/</guid><description>The Collatz conjecture, named for Lothar Collatz, goes as follows.
Take any positive integer \(n\). If \(n\) is even, half it, or if it&amp;rsquo;s odd, multiply it by three and add one. Repeating the process will always bring you back to 1.
The sequence of numbers generated by repeating the process is sometimes called the hailstone sequence due to the strange way the sequence bounces around, as you can see below if we start the sequence at 19.</description></item><item><title>Setting Up This Site</title><link>https://jamiejquinn.com/setting-up-this-site/</link><pubDate>Sat, 09 Apr 2016 00:00:00 +0000</pubDate><guid>https://jamiejquinn.com/setting-up-this-site/</guid><description>First there was a purely html site. I was about eleven.
Then, there was the Wordpress blog (or maybe Blogger). I was probably about thirteen.
After that came the social networks, Myspace, Bebo, Twitter, Facebook and Instagram, and then I decided I needed an actual blog for some reason. In my naivety I went for a full blown CMS stack, Mezzanine, a Django project. It took about a week solid, buying server space, setting up the entire site, finding a theme, tweaking the theme, breaking the theme, etc.</description></item></channel></rss>