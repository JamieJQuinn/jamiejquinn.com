<!doctype html><html lang=en-GB><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://jamiejquinn.com/static/favicon.ico><title>Running Fluid Simulations in WebGL I - Simple Convection | Jamie J Quinn</title>
<meta name=title content="Running Fluid Simulations in WebGL I - Simple Convection"><meta name=description content="Years ago I worked my way through Lorena Barba&rsquo;s 12 steps to Navier-Stokes in Python, but recently I&rsquo;ve been getting more and more into GPU programming and figured that it would be an interesting exercise to redo the steps in WebGL. Really when I say GPU programming I mean using general purpose tech like CUDA, but CUDA and WebGL are similar enough (the boilerplate is of course totally different but the idea of writing a kernel to act on many pixels/fluid cells is the same)."><meta name=keywords content="mathematics,code,fluid-dynamics,webgl,"><meta property="og:url" content="https://jamiejquinn.com/running-fluid-simulations-in-webgl-i-simple-convection/"><meta property="og:site_name" content="Jamie J Quinn"><meta property="og:title" content="Running Fluid Simulations in WebGL I - Simple Convection"><meta property="og:description" content="Years ago I worked my way through Lorena Barba&amp;rsquo;s 12 steps to Navier-Stokes in Python, but recently I&amp;rsquo;ve been getting more and more into GPU programming and figured that it would be an interesting exercise to redo the steps in WebGL. Really when I say GPU programming I mean using general purpose tech like CUDA, but CUDA and WebGL are similar enough (the boilerplate is of course totally different but the idea of writing a kernel to act on many pixels/fluid cells is the same)."><meta property="og:locale" content="en-GB"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-07-29T00:00:00+00:00"><meta property="article:modified_time" content="2018-07-29T00:00:00+00:00"><meta property="article:tag" content="Mathematics"><meta property="article:tag" content="Code"><meta property="article:tag" content="Fluid-Dynamics"><meta property="article:tag" content="Webgl"><meta property="og:image" content="https://jamiejquinn.com/images/share.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jamiejquinn.com/images/share.png"><meta name=twitter:title content="Running Fluid Simulations in WebGL I - Simple Convection"><meta name=twitter:description content="Years ago I worked my way through Lorena Barba&rsquo;s 12 steps to Navier-Stokes in Python, but recently I&rsquo;ve been getting more and more into GPU programming and figured that it would be an interesting exercise to redo the steps in WebGL. Really when I say GPU programming I mean using general purpose tech like CUDA, but CUDA and WebGL are similar enough (the boilerplate is of course totally different but the idea of writing a kernel to act on many pixels/fluid cells is the same)."><meta itemprop=name content="Running Fluid Simulations in WebGL I - Simple Convection"><meta itemprop=description content="Years ago I worked my way through Lorena Barba&rsquo;s 12 steps to Navier-Stokes in Python, but recently I&rsquo;ve been getting more and more into GPU programming and figured that it would be an interesting exercise to redo the steps in WebGL. Really when I say GPU programming I mean using general purpose tech like CUDA, but CUDA and WebGL are similar enough (the boilerplate is of course totally different but the idea of writing a kernel to act on many pixels/fluid cells is the same)."><meta itemprop=datePublished content="2018-07-29T00:00:00+00:00"><meta itemprop=dateModified content="2018-07-29T00:00:00+00:00"><meta itemprop=wordCount content="2060"><meta itemprop=image content="https://jamiejquinn.com/images/share.png"><meta itemprop=keywords content="Mathematics,Code,Fluid-Dynamics,Webgl"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{text-decoration:none;color:#c50}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%;display:block;margin-left:auto;margin-right:auto}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#3273dc}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script></head><body><header><a href=/ class=title><h2>Jamie J Quinn / Running Fluid Simulations in WebGL I - Simple Convection</h2></a><nav><a href=/>Home</a>
<a href=/blog/>Blog</a>
<a href=/presentations/>Presentations</a>
<a href=/projects/>Projects</a>
<a href=/publications/>Publications</a>
<a href=/tunes/>Tunes</a>
<a href=http://art.jamiejquinn.com>Art</a>
<a href=/jamie_quinn_cv.pdf>CV</a></nav></header><main><h1>Running Fluid Simulations in WebGL I - Simple Convection</h1><p><i><time datetime=2018-07-29 pubdate>29 Jul, 2018</time></i></p><content><p>Years ago I worked my way through Lorena Barba&rsquo;s <a href=http://lorenabarba.com/blog/cfd-python-12-steps-to-navier-stokes/>12 steps to Navier-Stokes</a> in Python, but recently I&rsquo;ve been getting more and more into GPU programming and figured that it would be an interesting exercise to redo the steps in WebGL. Really when I say GPU programming I mean using general purpose tech like CUDA, but CUDA and WebGL are similar enough (the boilerplate is of course totally different but the idea of writing a kernel to act on many pixels/fluid cells is the same). Plus you get easy, automatic visualisation with WebGL!</p><p>If you want to dive straight in, check out the simulation <a href=http://jamiejquinn.com/George-GL/01-non-linear-convection/>here</a> or the code <a href=https://github.com/JamieJQuinn/George-GL>here</a>.</p><h2 id=who-is-this-for>Who Is This For?</h2><p>Just like Barba has for her course, I&rsquo;m going to assume everyone reading this has a very basic understanding of fluid mechanics, partial differential equations, and numerical methods. By this I mean you should know what a partial derivative is, how you can model fluid behaviour using partial derivatives, and why numerical methods are used to solve fluid equations.</p><p>The code will be fairly simple as well, there&rsquo;s not too much software engineering that goes into these small numerical experiments, although I&rsquo;ll say now that the amount of code required to set up even a simple WebGL program is reasonably involved. As a benchmark, as someone who has never used WebGL before, I managed to set all this up in probably around 3 hours. I&rsquo;ll be using a little bit of:</p><ul><li>Javascript - A web programming language. A good basic learning resource is the classic <a href=https://www.w3schools.com/jS/default.asp>w3schools</a>.</li><li>WebGL - A library written for javascript. Check out <a href=https://webgl2fundamentals.org/>https://webgl2fundamentals.org/</a> for a good tutorial and reference.</li><li>GLSL - This is the shader language used by WebGL, see <a href=https://webgl2fundamentals.org/>https://webgl2fundamentals.org/</a> again.</li></ul><p>By the end of this, you should have the basic understanding of fluid equations, WebGL programming, and numerical methods to create something that looks unfortunately rather boring:</p><p>However, don&rsquo;t despair, simulating simple linear convection in 1 dimensions is just the foundation of computational fluid dynamics. We will very quickly and very easily move into more interesting 1D models, and then finally into simulating the fully 2D Navier-Stokes equations, the main set of fluid equations still used today. Beyond that, and beyond Barba&rsquo;s course, we might even end up exploring more complex methods, such as <a href=http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/ns.pdf>Stam&rsquo;s classic method</a> for quickly and stably simulating real time fluids in real time.</p><h2 id=the-fluid-mechanics>The Fluid Mechanics</h2><p>As in Prof. Barba&rsquo;s <a href=http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/01_Step_1.ipynb>first lesson</a> I&rsquo;ll take the 1-dimensional linear convection (or advection) equation, where we have a quantity \(u\) sitting in a fluid that&rsquo;s advected at a speed \(c\):</p><p>\(\frac{\partial u}{\partial t} + c\frac{\partial{u}}{\partial x} = 0.\)</p><p>For simplicity we&rsquo;ll only deal with this fluid between \(x=0\) and \(x=1\).</p><p>The simplest way to transform this equation into a problem solvable by a computer is to <strong>discretise</strong> the derivatives. We start by splitting our 1D space into \(N_x\) points, each separated by \(\Delta x=1/N_x\), and then splitting time in a similar way, stepping forward by a <strong>timestep</strong> \(\Delta t\). The solution \(u\) at a point \(x=i\Delta x\) and a time \(t=n\Delta t\) can then be written as \(u_i^n\). Then, using a <strong>backward difference</strong> formula, the spatial derivative can be approximated as,</p>$$\frac{\partial{u}}{\partial x} \approx \frac{u_i^n - u_{i-1}^n}{\Delta x},$$<p>and, using <strong>forward differences</strong>, the time derivative becomes,</p>$$\frac{\partial{u}}{\partial t} \approx \frac{u_i^{n+1} - u_{i}^{n}}{\Delta t}.$$<p>It should be fairly obvious why these difference formulae are called forward and backwards differences. Forward differencing calculates derivatives from the \(k\) and \(k+1\) states, while backward differences are calculated from the \(k\) and \(k-1\) states. Central differences are also an option but create strange numerical oscillations when applied to this particular problem, I&rsquo;ll discuss them when dealing with a diffusion problem.</p><p>There is an <a href=https://en.wikipedia.org/wiki/Numerical_partial_differential_equations>entire field of mathematics</a> dedicated to the development and analysis of these approximation of derivatives. This particular technique of combining temporal forward differences with spatial backward differences is a form of the <strong>first-order upwind method</strong>. It&rsquo;s shown to be <strong>stable</strong> when the fluid is moving to the right (and can be modified so the correct spatial difference is chosen based on which direction the fluid is moving) and can be shown to have <strong>first-order accuracy</strong>, meaning the errors that appear will be roughly the same size as \(\Delta t\) and \(\Delta x\). Methods of \(j\)-th order accuracy have errors proportional to \(\Delta x^j\) and/or \(\Delta t^j\) and higher. The upwind method, though not used much in practice due to it not being terribly accurate, is certainly useful for playing about with. After reading the rest of this post, try implementing <a href=https://en.wikipedia.org/wiki/Upwind_scheme#First-order_upwind_scheme>the scheme</a> for both right-moving and left-moving fluids, or increasing the accuracy using the <a href=https://en.wikipedia.org/wiki/Upwind_scheme#Second-order_upwind_scheme>second-order upwind scheme</a>.</p><p>Using these approximations the partial differential equation becomes a finite difference equation,</p>$$\frac{u_i^{n+1} - u_{i}^{n}}{\Delta t} + c\frac{u_i^n - u_{i-1}^n}{\Delta x} = 0,$$<p>which can be rearranged to give,</p>$$u_i^{n+1} = u_i^{n} - c\frac{\Delta t}{\Delta x}(u_i^n - u_{i-1}^n).$$<p>So, if we know an initial state \(u^0_i\) at every point \(i\), we can work out \(u^1_i\), then \(u^2_i\), and so forth. The upwind scheme is part of a family of methods called <strong>explicit schemes</strong>. This means the future state \(u_i^{n+1}\) can be written <strong>explicitly</strong> in terms of current or past states \(u_i^{n,n-1,n-2,...}\). The alternative is to incorporate future states into the calculation in a more intricate way, producing an <strong>implicit</strong> scheme. These are usually much more stable, often more accurate, but certainly a little harder to understand and code, and can really only be used on <strong>linear</strong> problems. I&rsquo;ll discuss implicit schemes a little more in future posts!</p><p>Now it should be quite clear that we&rsquo;ve finally found an equation suitable for a computer to solve, an equation that ultimately helps us simulate how a 1D fluid will behave, as long as we know the initial state \(u^0_i\) and the boundary behaviour. It should be said our original PDE does actually have a known <strong>analytical</strong> solution, that is a fully accurate solution we can write as a function \(u(x, t)\) for any time \(t\), at any point \(x\). It can be found using the <a href=https://services.math.duke.edu/education/joma/sarra/sarra2.html>method of characteristics</a>. However, this is a particularly simple case and as we add complexity to the fluid equation, it becomes usually impossible to find anything other than a <strong>numerical</strong> solution through the application of this kind of numerical method.</p><h2 id=the-code>The Code</h2><p>Now technically, I could take that final equation, give myself a starting state, and manually, by hand, work out every little calculation until I run out of time, food or any kind of semblance of sanity, but I won&rsquo;t because computers exists. I&rsquo;m not going to go through the code in detail because, frankly, it&rsquo;s not very interesting and mostly copied from the <a href=https://webgl2fundamentals.org/webgl/lessons/webgl-image-processing.html>WebGL2 Fundamentals image processing tutorial</a> anyway.</p><p>We&rsquo;re going to represent the grid of points as a texture in WebGL, with one texture representing the state at time \(n-1\) and another at \(n\), so by rendering between them and applying our finite difference formula we simulate the fluid from one time to the next. Of course a texture is a 2D grid of points, good for later when we finally move to interesting 2D simulations, but our problem right now is only 1D, so I&rsquo;m only going to deal with the \(x\) direction right now.</p><p>The only part that differs greatly from a more typical use of textures is that, because we&rsquo;re trying to run a decently accurate simulation, I&rsquo;ve instructed the texture to be created with an internal format of <code>RGBA32I</code> which assigns 32 bits per colour channel. Not as precise as the standard of 64 bits in true high performance computing, but good enough for us!</p><p>Every part of our simulation then uses shaders that act on these textures. The initial conditions are encoded in a shader, the finite difference formula that advances the simulation is a shader, even the boundary conditions are encoded in a shader that acts only at the edges of the texture.</p><p>The object that actually gets rendered is just a square of size \(2\times2\), linked to the shaders via a <a href=https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html>vertex array object</a>. Most of the shaders render this square using two triangles that cover the entire square. The odd shader out is the one encoding the boundary conditions, which simply draws lines around the square.</p><p>The full pseudocode looks a little like this:</p><ol><li>Set up WebGL context</li><li>Create rendering surfaces:<ol><li>Create two textures of simulation size</li><li>Link to two framebuffers for rendering</li></ol></li><li>Compile and link shaders:<ol><li>Initial condition shader</li><li>Simulation shader</li><li>Boundary shader</li><li>Screen rendering shader</li></ol></li><li>Load initial conditions into a texture</li><li>Run main loop:<ol><li>Render using main simulation shader from one texture to another</li><li>Render boundary conditions</li><li>Render result to screen</li><li>Swap textures</li></ol></li></ol><p>The actual code can be found on <a href=https://github.com/JamieJQuinn/George-GL/tree/master/01-non-linear-convection>github</a>. Start reading <code>main.js</code> and it should be fairly self-explanatory.</p><h3 id=the-shaders>The Shaders</h3><p>We have 3 interesting shaders and 1 very boring shader. The screen rendering shader simply copies a texture directly to the screen, allowing us to see what state our simulation is in. It&rsquo;s common to visualise the fluid motion using something that flows around with the fluid like ink. In this example I&rsquo;ve set the ink to be the variable \(u\). The only thing the screen shader is used for is interpolating from the colour of the background to the colour of this ink.</p><p>Since we&rsquo;re constantly rendering a square with four simple vertices, the vertex shader isn&rsquo;t doing anything particularly interesting, the meat is all in the fragment shaders. The only thing the vertex shader is doing is interpolating the texture coordinate to be used in the fragment shader.</p><h4 id=initial-conditions>Initial Conditions</h4><p>The first interesting shader is the initial conditions fragment shader:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>#version 300 es</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> <span style=color:#66d9ef>vec2</span> vTextureCoord;
</span></span><span style=display:flex><span><span style=color:#66d9ef>out</span> <span style=color:#66d9ef>vec4</span> outColour;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> pos <span style=color:#f92672>=</span> vTextureCoord.xy;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(pos.x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.1</span> <span style=color:#f92672>&amp;&amp;</span> pos.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.3</span>) {
</span></span><span style=display:flex><span>    outColour <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    outColour <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we can see how the texture is being used to store the state of the system,</p>$$(R,G,B) = (c, 0, u),$$<p>where we&rsquo;re using the red, green, blue and alpha channels to store the \(x\)-velocity or \(c\) (set to \(1\) for simplicity), \(y\)-velocity (\(0\) for now), and the ink level, \(u\).</p><p>What this shader does is it sets the \(x\)-velocity to be \(1\) everywhere, and creates a little pocket of ink between \(x=0.1\) and \(x=0.3\), letting the ink level be \(0\) everywhere else. That is, it encodes the function</p>$$u(x, 0) = \begin{cases}
1, & x \in (0.1, 0.3) \\[2ex]
0, & \text{otherwise}
\end{cases}$$<h4 id=main-simulation>Main Simulation</h4><p>The main simulation fragment shader is written as</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>#version 300 es</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>highp</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> <span style=color:#66d9ef>vec2</span> vTextureCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> uSampler;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> dt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> dxy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>out</span> <span style=color:#66d9ef>vec4</span> outColour;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Get variables</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> u <span style=color:#f92672>=</span> texture(uSampler, vTextureCoord).xy;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> ink <span style=color:#f92672>=</span> texture(uSampler, vTextureCoord).z;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> inkmx <span style=color:#f92672>=</span> texture(uSampler, <span style=color:#66d9ef>vec2</span>(vTextureCoord.x <span style=color:#f92672>-</span> dxy.x, vTextureCoord.y)).z;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Perform numerical calculation</span>
</span></span><span style=display:flex><span>  ink <span style=color:#f92672>=</span> ink <span style=color:#f92672>-</span> u.x <span style=color:#f92672>*</span> dt <span style=color:#f92672>/</span> dxy.x <span style=color:#f92672>*</span> (ink <span style=color:#f92672>-</span> inkmx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Output results</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> alpha <span style=color:#f92672>=</span> texture(uSampler, vTextureCoord).w;
</span></span><span style=display:flex><span>  outColour <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(u, ink, alpha);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Recall the difference formula</p>$$u_i^{n+1} = u_i^{n} - c\frac{\Delta t}{\Delta x}(u_i^n - u_{i-1}^n).$$<p>The shader encodes this formula, using the previous values <code>ink</code> and <code>inkmx</code> (as in ink-minus-x) as \(u^n_i\) and \(u^n_{i-1}\) sampled from the texture storing the previous state. As can be seen from the code, we find the \(i-1\) value by moving the sample coordinate a single \(dx\) to the left, the distance \(dx\) calculated using <code>1.0/gl.canvas.width</code>.</p><h4 id=boundary-conditions>Boundary Conditions</h4><p>The boundary shader is a little more interesting because we&rsquo;re not rendering (or simulating) over the full domain, since the boundary conditions should only affect the pixels around the edges. So instead of rendering to a square, we simply render lines around the domain using <code>gl.LINE_LOOP</code>. The shader itself sets the velocity and ink level at the boundary to \(0\) by returning <code>gl_FragColor = vec4(0,0,0,0)</code>.</p><h2 id=conclusion>Conclusion</h2><p>So, to wrap up, we&rsquo;ve gone over the basics of fluid mechanics, written through the language of partial differential equations. We&rsquo;ve transformed those equations into finite difference formulae that can be readily calculated by a computer. Finally, we&rsquo;ve figured out a way we can write those formulae using javascript and WebGL to simulate the fluid in real time on any modern graphics card, all within the browser!</p><p>Next up, we&rsquo;ll explore moving to 2D, and simulating a few more interesting 1D fluid equations.</p></content><p><a href=https://jamiejquinn.com/tags/mathematics/>#Mathematics</a>
<a href=https://jamiejquinn.com/tags/code/>#Code</a>
<a href=https://jamiejquinn.com/tags/fluid-dynamics/>#Fluid-Dynamics</a>
<a href=https://jamiejquinn.com/tags/webgl/>#Webgl</a></p></main><footer><p><a href=mailto:jamiejquinn@jamiejquinn.com>Email</a> / <a href=https://www.github.com/jamiejquinn>Github</a> / <a href=https://www.instagram.com/jamiejquinn>Instagram</a> / <a href=https://twitter.com/jimjonquinn>Twitter</a></p></footer></body></html>